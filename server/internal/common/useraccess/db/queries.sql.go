// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getByUsername = `-- name: GetByUsername :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(t.debit, 0) as debit,
    coalesce(t.credit, 0) as credit
from users u
left join user_totals t on u.id = t.user_id
where u.username = $1
limit 1
`

type GetByUsernameRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	Debit     float64
	Credit    float64
}

func (q *Queries) GetByUsername(ctx context.Context, username string) (GetByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getByUsername, username)
	var i GetByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(t.debit, 0) as debit,
    coalesce(t.credit, 0) as credit
from users u
left join user_totals t on u.id = t.user_id
where u.email = $1
limit 1
`

type GetUserByEmailRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	Debit     float64
	Credit    float64
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(t.debit, 0) as debit,
    coalesce(t.credit, 0) as credit
from users u
left join user_totals t on u.id = t.user_id
where u.id = $1
limit 1
`

type GetUserByIDRow struct {
	ID        uuid.UUID
	Username  string
	Email     string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	Debit     float64
	Credit    float64
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
	)
	return i, err
}

const userWithEmailExists = `-- name: UserWithEmailExists :one
select exists(select 1 from users where email = $1)
`

func (q *Queries) UserWithEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userWithEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userWithUsernameExists = `-- name: UserWithUsernameExists :one
select exists(select 1 from users where username = $1)
`

func (q *Queries) UserWithUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userWithUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
