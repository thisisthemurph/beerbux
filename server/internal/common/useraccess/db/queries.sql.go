// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getByUsername = `-- name: GetByUsername :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(ut.debit, 0) as debit,
    coalesce(ut.credit, 0) as credit,
    coalesce(ucs.credit_score, 0) as credit_score
from users u
left join user_totals ut on u.id = ut.user_id
left join user_credit_score ucs on u.id = ucs.user_id
where u.username = $1
limit 1
`

type GetByUsernameRow struct {
	ID          uuid.UUID
	Username    string
	Email       string
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Debit       float64
	Credit      float64
	CreditScore float64
}

func (q *Queries) GetByUsername(ctx context.Context, username string) (GetByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getByUsername, username)
	var i GetByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
		&i.CreditScore,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(ut.debit, 0) as debit,
    coalesce(ut.credit, 0) as credit,
    coalesce(ucs.credit_score, 0) as credit_score
from users u
left join user_totals ut on u.id = ut.user_id
left join user_credit_score ucs on u.id = ucs.user_id
where u.email = $1
limit 1
`

type GetUserByEmailRow struct {
	ID          uuid.UUID
	Username    string
	Email       string
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Debit       float64
	Credit      float64
	CreditScore float64
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
		&i.CreditScore,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
select
    u.id, u.username, u.email, u.name, u.created_at, u.updated_at,
    coalesce(ut.debit, 0) as debit,
    coalesce(ut.credit, 0) as credit,
    coalesce(ucs.credit_score, 0) as credit_score
from users u
left join user_totals ut on u.id = ut.user_id
left join user_credit_score ucs on u.id = ucs.user_id
where u.id = $1
limit 1
`

type GetUserByIDRow struct {
	ID          uuid.UUID
	Username    string
	Email       string
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Debit       float64
	Credit      float64
	CreditScore float64
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
		&i.CreditScore,
	)
	return i, err
}

const getUserCreditScore = `-- name: GetUserCreditScore :one
select user_id, beers_given, beers_received, balance_ratio, avg_reciprocation_ratio, recent_giving, credit_score, status_label from user_credit_score where user_id = $1 limit 1
`

func (q *Queries) GetUserCreditScore(ctx context.Context, userID uuid.UUID) (UserCreditScore, error) {
	row := q.db.QueryRowContext(ctx, getUserCreditScore, userID)
	var i UserCreditScore
	err := row.Scan(
		&i.UserID,
		&i.BeersGiven,
		&i.BeersReceived,
		&i.BalanceRatio,
		&i.AvgReciprocationRatio,
		&i.RecentGiving,
		&i.CreditScore,
		&i.StatusLabel,
	)
	return i, err
}

const userWithEmailExists = `-- name: UserWithEmailExists :one
select exists(select 1 from users where email = $1)
`

func (q *Queries) UserWithEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userWithEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userWithUsernameExists = `-- name: UserWithUsernameExists :one
select exists(select 1 from users where username = $1)
`

func (q *Queries) UserWithUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userWithUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
