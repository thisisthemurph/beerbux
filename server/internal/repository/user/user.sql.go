// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user.sql

package user

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const get = `-- name: Get :one
select u.id, u.username, u.name, u.created_at, u.updated_at,
       t.debit, t.credit
from users u
left join user_totals t on u.id = t.user_id
where u.id = $1
limit 1
`

type GetRow struct {
	ID        uuid.UUID
	Username  string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	Debit     float64
	Credit    float64
}

func (q *Queries) Get(ctx context.Context, id uuid.UUID) (GetRow, error) {
	row := q.db.QueryRowContext(ctx, get, id)
	var i GetRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
	)
	return i, err
}

const getByUsername = `-- name: GetByUsername :one
select u.id, u.username, u.name, u.created_at, u.updated_at,
       t.debit, t.credit
from users u
left join user_totals t on u.id = t.user_id
where u.username = $1
limit 1
`

type GetByUsernameRow struct {
	ID        uuid.UUID
	Username  string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	Debit     float64
	Credit    float64
}

func (q *Queries) GetByUsername(ctx context.Context, username string) (GetByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getByUsername, username)
	var i GetByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Debit,
		&i.Credit,
	)
	return i, err
}

const update = `-- name: Update :one
update users
set name = $1, username = $2
where id = $3
returning id, username, name, created_at, updated_at
`

type UpdateParams struct {
	Name     string
	Username string
	ID       uuid.UUID
}

type UpdateRow struct {
	ID        uuid.UUID
	Username  string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (UpdateRow, error) {
	row := q.db.QueryRowContext(ctx, update, arg.Name, arg.Username, arg.ID)
	var i UpdateRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTotals = `-- name: UpdateTotals :exec
insert into user_totals (user_id, credit, debit)
values ($1, $2, $3)
on conflict (user_id) do update
set credit = excluded.credit, debit = excluded.debit
`

type UpdateTotalsParams struct {
	UserID uuid.UUID
	Credit float64
	Debit  float64
}

func (q *Queries) UpdateTotals(ctx context.Context, arg UpdateTotalsParams) error {
	_, err := q.db.ExecContext(ctx, updateTotals, arg.UserID, arg.Credit, arg.Debit)
	return err
}

const userWithUsernameExists = `-- name: UserWithUsernameExists :one
select exists(select 1 from users where username = $1)
`

func (q *Queries) UserWithUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userWithUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
